{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"A tiny API client for the Pelias Libpostal REST service. Documentation : https://dribia.github.io/dripostal Source Code : https://github.com/dribia/dripostal Libpostal is a widely known C library for parsing and normalizing street addresses around the world. Despite having its own Python bindings, getting to install the library can be quite hard and time-consuming. A common workaround is then to use a dockerized service exposing Libpostal as a REST API, e.g. Pelias' Libpostal REST service . Dripostal aims to provide a Python interface with such API, both in the synchronous and the asynchronous ways. Key features \ud83d\udd17 Query Libpostal's parse and expand methods. Return results as Pydantic models. Provides a mirror async client enabling asynchronous queries to the Libpostal REST service. Example \ud83d\udd17 In order to successfully run the following example, a Libpostal service should be running locally: docker run -d -p 4400 :4400 pelias/libpostal-service Info The command above will be pulling the libpostal-service Docker image from Pelias and running a container that will serve the Libpostal REST service through its port 4400. With option -p 4400:4400 we are mapping port 4400 in the docker container to port 4400 in the docker host, i.e. your computer. You could map it to another port of the host, e.g. the 8080 , changing 4400:4400 for 8080:4400 . With option -d we are running the docker container in detached mode , i.e. in the background. Now we should be able to run the following code: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) dripostal . parse ( \"Planta 3 m\u00f2dul 303, Carrer de la Llacuna, 162, 08018 Barcelona\" ) \"\"\" Address( house='m\u00f2dul 303', house_number='162', road='carrer de la llacuna', level='planta 3', postcode='08018', city='barcelona', country=None, ... ) \"\"\"","title":"dripostal"},{"location":"#key-features","text":"Query Libpostal's parse and expand methods. Return results as Pydantic models. Provides a mirror async client enabling asynchronous queries to the Libpostal REST service.","title":"Key features"},{"location":"#example","text":"In order to successfully run the following example, a Libpostal service should be running locally: docker run -d -p 4400 :4400 pelias/libpostal-service Info The command above will be pulling the libpostal-service Docker image from Pelias and running a container that will serve the Libpostal REST service through its port 4400. With option -p 4400:4400 we are mapping port 4400 in the docker container to port 4400 in the docker host, i.e. your computer. You could map it to another port of the host, e.g. the 8080 , changing 4400:4400 for 8080:4400 . With option -d we are running the docker container in detached mode , i.e. in the background. Now we should be able to run the following code: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) dripostal . parse ( \"Planta 3 m\u00f2dul 303, Carrer de la Llacuna, 162, 08018 Barcelona\" ) \"\"\" Address( house='m\u00f2dul 303', house_number='162', road='carrer de la llacuna', level='planta 3', postcode='08018', city='barcelona', country=None, ... ) \"\"\"","title":"Example"},{"location":"contribute/","text":"Contribute \ud83d\udd17 Contributions to Dribia libraries are always welcome! Mantainers \ud83d\udd17 Dripostal is maintained by: Nabil Kakeh - nabil@dribia.com Albert Iribarne - iribarne@dribia.com Issues \ud83d\udd17 Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import dripostal; print(dripostal.__version__)\" It would be very useful too to know which OS and Python version are your running dripostal from. Contribute \ud83d\udd17 In order to contribute, the first step is to clone yourself the code: repository : git clone https://github.com/dribia/dripostal.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . Remember that you can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"contribute/#contribute","text":"Contributions to Dribia libraries are always welcome!","title":"Contribute"},{"location":"contribute/#mantainers","text":"Dripostal is maintained by: Nabil Kakeh - nabil@dribia.com Albert Iribarne - iribarne@dribia.com","title":"Mantainers"},{"location":"contribute/#issues","text":"Questions, feature requests and bug reports are all welcome as discussions or issues . Please note which version of the library are you using whenever reporting a bug. python -c \"import dripostal; print(dripostal.__version__)\" It would be very useful too to know which OS and Python version are your running dripostal from.","title":"Issues"},{"location":"contribute/#contribute_1","text":"In order to contribute, the first step is to clone yourself the code: repository : git clone https://github.com/dribia/dripostal.git Then, you can step into the project's root and, assuming that you have both Poetry and pre-commit installed, run: poetry install && pre-commit install Now you should be ready to start coding and prepare your pull request . Remember that you can run linting and tests locally with: sh scripts/lint.sh sh scripts/test.sh Happy coding!","title":"Contribute"},{"location":"install/","text":"PIP \ud83d\udd17 Installation is as simple as: pip install dripostal Dripostal's only dependency is Pydantic , a data validation framework we use to build Dripostal's response schemas: Async \ud83d\udd17 To use the asynchronous Dripostal client provided in the dripostal.aio module you should have AIOHTTP already installed, or install it as an extra dependency for Dripostal: pip install dripostal [ aiohttp ]","title":"Install"},{"location":"install/#pip","text":"Installation is as simple as: pip install dripostal Dripostal's only dependency is Pydantic , a data validation framework we use to build Dripostal's response schemas:","title":"PIP"},{"location":"install/#async","text":"To use the asynchronous Dripostal client provided in the dripostal.aio module you should have AIOHTTP already installed, or install it as an extra dependency for Dripostal: pip install dripostal [ aiohttp ]","title":"Async"},{"location":"usage/async/","text":"DriPostal offers also an asynchronous client to interact with the Libpostal service. Using the asynchronous client instead of the standard one might be a bit more complicated, but can introduce significant performance improvements. Note that Dripostal needs the AIOHTTP library to run the async client. It can be installed as an optional dependency . Usage \ud83d\udd17 This is the simplest example we can think of: Python >=3.7 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = asyncio . run ( dripostal . parse ( \"Carrer de la Llacuna, 162, 08018\" )) print ( type ( response )) \"\"\" <class 'dripostal.schemas.Address'> \"\"\" Python 3.6 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) loop = asyncio . get_event_loop () response = loop . run_until_complete ( dripostal . parse ( \"Carrer de la Llacuna, 162, 08018\" )) loop . close () print ( type ( response )) \"\"\" <class 'dripostal.schemas.Address'> \"\"\" Note how the response type is an Address model, the same type we would obtain from the standard synchronous client. Now, the most common use-case would be to parse -or expand- a list of addresses. Python >= 3.7 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) addresses = [ \"777 Brockton Avenue, Abington MA 2351\" , \"30 Memorial Drive, Avon MA 2322\" , \"250 Hartford Avenue, Bellingham MA 2019\" , ] async def main (): return await asyncio . gather ( * list ( map ( dripostal . parse , addresses ))) results = asyncio . run ( main ()) print ( results ) \"\"\" [ Address(house=None, ...), Address(house=None, ...), Address(house=None, ...), ] \"\"\" Python 3.6 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) addresses = [ \"777 Brockton Avenue, Abington MA 2351\" , \"30 Memorial Drive, Avon MA 2322\" , \"250 Hartford Avenue, Bellingham MA 2019\" , ] async def main (): return await asyncio . gather ( * list ( map ( dripostal . parse , addresses ))) loop = asyncio . get_event_loop () results = loop . run_until_complete ( main ()) loop . close () print ( results ) \"\"\" [ Address(house=None, ...), Address(house=None, ...), Address(house=None, ...), ] \"\"\"","title":"Async"},{"location":"usage/async/#usage","text":"This is the simplest example we can think of: Python >=3.7 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = asyncio . run ( dripostal . parse ( \"Carrer de la Llacuna, 162, 08018\" )) print ( type ( response )) \"\"\" <class 'dripostal.schemas.Address'> \"\"\" Python 3.6 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) loop = asyncio . get_event_loop () response = loop . run_until_complete ( dripostal . parse ( \"Carrer de la Llacuna, 162, 08018\" )) loop . close () print ( type ( response )) \"\"\" <class 'dripostal.schemas.Address'> \"\"\" Note how the response type is an Address model, the same type we would obtain from the standard synchronous client. Now, the most common use-case would be to parse -or expand- a list of addresses. Python >= 3.7 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) addresses = [ \"777 Brockton Avenue, Abington MA 2351\" , \"30 Memorial Drive, Avon MA 2322\" , \"250 Hartford Avenue, Bellingham MA 2019\" , ] async def main (): return await asyncio . gather ( * list ( map ( dripostal . parse , addresses ))) results = asyncio . run ( main ()) print ( results ) \"\"\" [ Address(house=None, ...), Address(house=None, ...), Address(house=None, ...), ] \"\"\" Python 3.6 import asyncio from dripostal.aio import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) addresses = [ \"777 Brockton Avenue, Abington MA 2351\" , \"30 Memorial Drive, Avon MA 2322\" , \"250 Hartford Avenue, Bellingham MA 2019\" , ] async def main (): return await asyncio . gather ( * list ( map ( dripostal . parse , addresses ))) loop = asyncio . get_event_loop () results = loop . run_until_complete ( main ()) loop . close () print ( results ) \"\"\" [ Address(house=None, ...), Address(house=None, ...), Address(house=None, ...), ] \"\"\"","title":"Usage"},{"location":"usage/expand/","text":"Libpostal's expand method allows us to parse a string containing an address and normalize it to its standard form. To make a query to our Libpostal's expand service using dripostal , we can run the following code: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = dripostal . expand ( \"C/ Ocho, P.I. 4\" ) print ( response ) \"\"\" [ 'calle 8 poligono industrial 4', 'carrer 8 poligon industrial 4', 'calle 8 piso 4', ] \"\"\" Note how the response of the expand method is a list of strings. This is because the address can have more than one normalized forms, as in the example above, where it is not clear if the original address is in Catalan or in Spanish.","title":"Expand"},{"location":"usage/intro/","text":"Libpostal \ud83d\udd17 Libpostal is a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. It has officially supported Python bindings in the PyPostal library. However, a common alternative is to run Libpostal as a REST service and query it to obtain the desired results, e.g. using the Pelias Libpostal REST service . Pelias Libpostal Service \ud83d\udd17 One of the best backed Libpostal services is the one that comes with Pelias . One can run the service using Docker with the following command: docker run -d -p 4400 :4400 pelias/libpostal-service Info The command above will be pulling the libpostal-service Docker image from Pelias and running a container that will serve the Libpostal REST service through its port 4400. With option -p 4400:4400 we are mapping port 4400 in the docker container to port 4400 in the docker host, i.e. your computer. You could map it to another port of the host, e.g. the 8080 , changing 4400:4400 for 8080:4400 . With option -d we are running the docker container in detached mode , i.e. in the background. DriPostal \ud83d\udd17 DriPostal allows us to query the two methods offered by Libpostal, namely: Parse : Parse a string containing an address to label its parts. Expand : Normalize a string containing an address to its standard form. The main object to use is the DriPostal class, which has interface methods to query such endpoints. To initialize the DriPostal class, one should provide the URL of the service. For instance, if you have used the command above to run the Pelias Libpostal REST service in your computer, you should initialize the class as follows: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) Now, with the dripostal object, you can make any query to both the parse and expand endpoints. Info There is also a mirror asynchronous client providing the same interface in the dripostal.aio module.","title":"Intro"},{"location":"usage/intro/#libpostal","text":"Libpostal is a C library for parsing/normalizing street addresses around the world using statistical NLP and open data. It has officially supported Python bindings in the PyPostal library. However, a common alternative is to run Libpostal as a REST service and query it to obtain the desired results, e.g. using the Pelias Libpostal REST service .","title":"Libpostal"},{"location":"usage/intro/#pelias-libpostal-service","text":"One of the best backed Libpostal services is the one that comes with Pelias . One can run the service using Docker with the following command: docker run -d -p 4400 :4400 pelias/libpostal-service Info The command above will be pulling the libpostal-service Docker image from Pelias and running a container that will serve the Libpostal REST service through its port 4400. With option -p 4400:4400 we are mapping port 4400 in the docker container to port 4400 in the docker host, i.e. your computer. You could map it to another port of the host, e.g. the 8080 , changing 4400:4400 for 8080:4400 . With option -d we are running the docker container in detached mode , i.e. in the background.","title":"Pelias Libpostal Service"},{"location":"usage/intro/#dripostal","text":"DriPostal allows us to query the two methods offered by Libpostal, namely: Parse : Parse a string containing an address to label its parts. Expand : Normalize a string containing an address to its standard form. The main object to use is the DriPostal class, which has interface methods to query such endpoints. To initialize the DriPostal class, one should provide the URL of the service. For instance, if you have used the command above to run the Pelias Libpostal REST service in your computer, you should initialize the class as follows: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) Now, with the dripostal object, you can make any query to both the parse and expand endpoints. Info There is also a mirror asynchronous client providing the same interface in the dripostal.aio module.","title":"DriPostal"},{"location":"usage/parse/","text":"Libpostal's parse method allows us to parse a string containing an address and label its parts, e.g. identify its road , city , country , etc. To make a query to our Libpostal's parse service using dripostal , we can run the following code: from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = dripostal . parse ( \"Carrer de la Llacuna, 162, 08018 Barcelona\" ) print ( type ( response )) \"\"\" <class 'dripostal.schemas.Address'> \"\"\" Address \ud83d\udd17 Note how the response variable of the above code chunk is of a special Address type. This is the response model of DriPostal's parse method, and is a Pydantic model. Then, its attributes are type-validated, currently being all of them str types. The attributes of the Address response model are every possible Libpostal's parse method label. A complete list can be found here . List \ud83d\udd17 PyPostal, the Libpostal's Python bindings library, returns the parse results as a list of tuples. This is why Address response models have a list method, to recover this structure. from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = dripostal . parse ( \"Carrer de la Llacuna, 162, 08018 Barcelona\" ) print ( type ( response . list ())) \"\"\" [('house', 'm\u00f2dul 303'), ('house_number', '162'), ...] \"\"\"","title":"Parse"},{"location":"usage/parse/#address","text":"Note how the response variable of the above code chunk is of a special Address type. This is the response model of DriPostal's parse method, and is a Pydantic model. Then, its attributes are type-validated, currently being all of them str types. The attributes of the Address response model are every possible Libpostal's parse method label. A complete list can be found here .","title":"Address"},{"location":"usage/parse/#list","text":"PyPostal, the Libpostal's Python bindings library, returns the parse results as a list of tuples. This is why Address response models have a list method, to recover this structure. from dripostal import DriPostal dripostal = DriPostal ( url = \"http://0.0.0.0:4400\" ) response = dripostal . parse ( \"Carrer de la Llacuna, 162, 08018 Barcelona\" ) print ( type ( response . list ())) \"\"\" [('house', 'm\u00f2dul 303'), ('house_number', '162'), ...] \"\"\"","title":"List"}]}